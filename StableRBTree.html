<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="StableRBTree.html">StableRBTree</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Color">Color</a></li></li><li><li><a href="#type.Tree">Tree</a></li></li><li><li><a href="#init">init</a></li></li><li><li><a href="#share">share</a></li></li><li><li><a href="#get">get</a></li></li><li><li><a href="#replace">replace</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#delete">delete</a></li></li><li><li><a href="#remove">remove</a></li></li><li><li><a href="#split">split</a></li></li><li><li><a href="#entries">entries</a></li></li><li><li><a href="#entriesRev">entriesRev</a></li></li><li><li><a href="#iter">iter</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#equalIgnoreDeleted">equalIgnoreDeleted</a></li></li><li><li><a href="#equalIncludeDeleted">equalIncludeDeleted</a></li></li></ul></nav><div class="documentation"><h1>StableRBTree</h1><p>Red-Black Trees</p>
<div class="declaration"><h4 class="type-declaration" id="type.Color"><span class="keyword">type </span><span class="type">Color</span> = {#R; #B}</h4><p><p>Node color: red or black.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Tree"><span class="keyword">type </span><span class="type">Tree</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = {#node : (<a href="#type.Color"><span class="type">Color</span></a>, <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, (<span class="type">K</span>, ?<span class="type">V</span>), <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;); #leaf}</h4><p><p>Ordered, (red-black) tree of entries.</p>
</p></div><div class="declaration"><h4 class="function" id="init"><code><span class="keyword">public func </span><span class="fnname">init</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;() : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Initializes an empty Red-Black Tree of type &lt;K, V&gt;
Returns this empty Red-Black Tree</p>
</p></div><div class="declaration"><h4 class="function" id="share"><code><span class="keyword">public func </span><span class="fnname">share</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Tree as sharable data.</p>
<p>Get non-OO, purely-functional representation:
for drawing, pretty-printing and non-OO contexts
(e.g., async args and results):</p>
</p></div><div class="declaration"><h4 class="function" id="get"><code><span class="keyword">public func </span><span class="fnname">get</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compareTo</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">O.Order</span>, <br/>  <span class="parameter">k</span> : <span class="type">K</span><br/>) : ?<span class="type">V</span></code></h4><p><p>Returns the value associated with a given key.</p>
</p></div><div class="declaration"><h4 class="function" id="replace"><code><span class="keyword">public func </span><span class="fnname">replace</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compareTo</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">O.Order</span>, <br/>  <span class="parameter">k</span> : <span class="type">K</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : (?<span class="type">V</span>, <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;)</code></h4><p><p>Replace the value associated with a given key.
Returns the replaced value (if exists) and the new tree</p>
</p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compareTo</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">O.Order</span>, <br/>  <span class="parameter">k</span> : <span class="type">K</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Put an entry: A value associated with a given key.
Returns the new tree</p>
</p></div><div class="declaration"><h4 class="function" id="delete"><code><span class="keyword">public func </span><span class="fnname">delete</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compareTo</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">O.Order</span>, <br/>  <span class="parameter">k</span> : <span class="type">K</span><br/>) : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Delete the entry associated with a given key.
Returns the new tree</p>
</p></div><div class="declaration"><h4 class="function" id="remove"><code><span class="keyword">public func </span><span class="fnname">remove</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compareTo</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">O.Order</span>, <br/>  <span class="parameter">k</span> : <span class="type">K</span><br/>) : (?<span class="type">V</span>, <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;)</code></h4><p><p>Remove the entry associated with a given key.
Returns the removed entry (if exists) and the new tree</p>
</p></div><div class="declaration"><h4 class="function" id="split"><code><span class="keyword">public func </span><span class="fnname">split</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">compareTo</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">O.Order</span>) : ?(<a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;)</code></h4><p><p>Splits a Red-Black Tree (t) into two Red-Black Trees (t1, t2). All of the nodes' keys in the first Red-Black Tree 
returned will be less than the nodes' keys in the second Red-Black Tree returned.</p>
<p>Note: this implementation mutates the tree passed in as it re-inserts the root node key values into the left child</p>
<p>Implementation: Splits a Red-Black tree into it's left child and right child trees, then
inserts the root node into the tree of the left child. Returns the right child Red-Black Tree,
and the result of reinserting the root node into the left child Red-Black Tree. Transforms the roots
of both trees it returns to black to protect the tree's invariants</p>
<p>Edge cases</p>
<ol><li>If the root is a #leaf (empty), returns two #leaf (empty) Red-Black Trees</li><li>If the tree contains a single #node at the root (both children are leaves, returns that node and a #leaf </li><li>If the tree contains a #node at the root and one child is a #leaf returns the a new tree with the root key and 
node's key and value, and the child which is a #node </li><li>If the root node was deleted (with a null value), just returns the left and right child Red-Black Trees. For an
explanation of how functional Red-Black Trees handle deletion, see https://matt.might.net/papers/germane2014deletion.pdf</li><li>If an invalid Red-Black Tree in terms of being unbalanced is passed to this function, the split will return null.
This is done instead of splitting the tree, in order to prevent a loss of data in the Red-Black Tree </li></ol></p></div><div class="declaration"><h4 class="function" id="entries"><code><span class="keyword">public func </span><span class="fnname">entries</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">I.Iter</span>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;</code></h4><p><p>An iterator for the key-value entries of the map, in ascending key order.</p>
<p>iterator is persistent, like the tree itself</p>
</p></div><div class="declaration"><h4 class="function" id="entriesRev"><code><span class="keyword">public func </span><span class="fnname">entriesRev</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">I.Iter</span>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;</code></h4><p><p>An iterator for the key-value entries of the map, in descending key order.</p>
<p>iterator is persistent, like the tree itself</p>
</p></div><div class="declaration"><h4 class="function" id="iter"><code><span class="keyword">public func </span><span class="fnname">iter</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">dir</span> : {#fwd; #bwd}) : <span class="type">I.Iter</span>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;</code></h4><p><p>An iterator for the entries of the map, in ascending (<code>#fwd</code>) or descending (<code>#bwd</code>) order.</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>The size of the tree as the number of key-value entries.</p>
</p></div><div class="declaration"><h4 class="function" id="equalIgnoreDeleted"><code><span class="keyword">public func </span><span class="fnname">equalIgnoreDeleted</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t1</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">t2</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">keyEquals</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">valueEquals</span> : (<span class="type">V</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>For most purposes, one should prefer this equalIgnoreDeleted function as opposed to equalIncludeDeleted.</p>
<p>Functional Red-Black trees do not have efficient operations for deleting a red black tree. For reference, see 
https://matt.might.net/papers/germane2014deletion.pdf.</p>
<p>Therefore, &quot;deleting&quot; a node is represented as setting the value to null for a specific key.</p>
<p>The equalIgnoreDeleted function returns a boolean value indicating if two Red-Black Trees are equivalent, ignoring node coloring
and focusing solely on node location and key value equality as per the keyEquals and valueEquals methods supplied.</p>
<p>Note the difference betweenn equalIgnoreDeleted and equalIncludeDeleted in the result of the last line in the following example.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">var t1 = RBT.init&lt;Nat, Text&gt;();
var t2 = RBT.init&lt;Nat, Text&gt;();
t1 := RBT.put&lt;Nat, Text&gt;(t1, Nat.compare, 35, &quot;john&quot;);
t2 := RBT.put&lt;Nat, Text&gt;(t1, Nat.compare, 35, &quot;john&quot;);
RBT.equalIgnoreDeleted&lt;Nat, Text&gt;(t1, t2, Nat.equal, Text.equal); // true
RBT.equalIncludeDeleted&lt;Nat, Text&gt;(t1, t2, Nat.equal, Text.equal); // true

t1 := RBT.put&lt;Nat, Text&gt;(t1, Nat.compare, 31, &quot;alice&quot;);
t1 := RBT.delete&lt;Nat, Text&gt;(t1, Nat.compare, 31);
RBT.equalIgnoreDeleted&lt;Nat, Text&gt;(t1, t2, Nat.equal, Text.equal); // true
RBT.equalIncludeDeleted&lt;Nat, Text&gt;(t1, t2, Nat.equal, Text.equal); // false </code></pre></p></div><div class="declaration"><h4 class="function" id="equalIncludeDeleted"><code><span class="keyword">public func </span><span class="fnname">equalIncludeDeleted</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t1</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">t2</span> : <a href="#type.Tree"><span class="type">Tree</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">keyEquals</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">valueEquals</span> : (<span class="type">V</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Functional Red-Black trees do not have efficient operations for deleting a red black tree. Therefore, &quot;deleting&quot; a node is
represented as setting the value to null for a specific key.</p>
<p>Returns a boolean value indicating if two Red-Black Trees are equivalent, including node coloring and deleted &quot;null&quot; nodes,
as well as node location and key value equality as per the keyEquals and valueEquals methods supplied</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">var t1 = RBT.init&lt;Nat, Text&gt;();
var t2 = RBT.init&lt;Nat, Text&gt;();
t1 := RBT.put&lt;Nat, Text&gt;(t1, Nat.compare, 35, &quot;john&quot;);
t2 := RBT.put&lt;Nat, Text&gt;(t1, Nat.compare, 35, &quot;john&quot;);
RBT.equalIncludeDeleted&lt;Nat, Text&gt;(t1, t2, Nat.equal, Text.equal); // true

t1 := RBT.put&lt;Nat, Text&gt;(t1, Nat.compare, 31, &quot;alice&quot;);
t1 := RBT.delete&lt;Nat, Text&gt;(t1, Nat.compare, 31);
RBT.equalIncludeDeleted&lt;Nat, Text&gt;(t1, t2, Nat.equal, Text.equal); // false </code></pre></p></div></div></body></html>